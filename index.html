<!DOCTYPE html>
<html>

<head>
    <title></title>
    <meta content="">
    <link href="./dist/bootstrap.min.css" rel="stylesheet">
    <style>
        .ref + .ref:before {
          content: ", ";
        }
        .comp + .comp:before {
            content: " + ";
        }
    </style>
    <script type="importmap">
      {
        "imports": {
          "vue": "./dist/vue.esm-browser.js",
          "glpk": "./dist/glpk.js"
        }
      }
    </script>
    <script src="./dist/es-module-shims.js"></script>
    <script type="text/javascript" async src="./dist/tex-mml-chtml.js"></script>
</head>

<body>
    <script src="./dist/jquery-3.6.0.min.js"></script>
    <script src="./dist/bootstrap.bundle.min.js"></script>

    <main id="app" role="main" class="container">
    
    <h1>Global Optimization of Lever Parameters</h1>
    
    
    <h2 id="ligand-data">Available Ligand Data <em><a href="#optimization">(&rarr; LP Optimization)</a></em></h2>
    <table class="table table-striped table-hover">
      <caption>Please contact the authors to have your data included, or make a pull request right here on GitHub.</caption>
      <thead class="table-dark">
        <tr>
          <th scope="col">#</th>
          <th scope="col">Ligand</th>
          <th scope="col">Components</th>
          <th scope="col">UEL</th>
          <th scope="col">Reference</th>
          <th scope="col">Ingnore</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="(l, i) in jsonl">
            <th scope="row">{{i}}</th>
            <td>{{l.lig}}</td>
            <td><span class="comp" v-for="(n, c) in l.eqn">{{n}} * {{c}}</span></td>
            <td>{{l.uel}}</td>
            <td>
                <span class="ref" v-if="Array.isArray(l.doi)" v-for="(d,j) in l.doi"><a v-bind:href="'https://doi.org/'+d">{{j+1}}</a> </span>
                <span v-else-if="l.doi"><a v-bind:href="'https://doi.org/'+l.doi">{{1}}</a> </span>
            </td>
            <td>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" v-model="l.ignore" alue="" id="flexCheckDefault">
            </div>
            </td>
        </tr>
      </tbody>
    </table>

    <h2 id="optimization">Solve LP</h2>

    <button type="button" class="btn btn-primary" @click="solve">Run optimization</button>

    <div v-if="error" class="alert alert-danger" role="alert">
        {{error}}
    </div>

    <table class="table table-striped table-hover">
      <caption v-if="!res">Please run solver to see solution.</caption>
      <thead class="table-dark">
        <tr>
          <th scope="col">Variable</th>
          <th scope="col">Component</th>
          <th scope="col">Value</th>
        </tr>
      </thead>
      <tbody>
        <tr v-if="res" v-for="u in uels">
            <th scope="row">{{u.var}}</th>
            <td>{{u.name}}</td>
            <td>{{u.val}}</td>
        </tr>
      </tbody>
    </table>

    <p v-show="cplex || res">
      <a v-show="cplex" class="btn btn-primary" data-bs-toggle="collapse" href="#collCplex" role="button" aria-expanded="false" aria-controls="collCplex">
        Show optimization problem
      </a>
      <a v-show="res" class="btn btn-primary" data-bs-toggle="collapse" href="#collRes" role="button" aria-expanded="false" aria-controls="collRes">
        Show solver output
      </a>
    </p>
    <div v-if="res" class="collapse" id="collRes">
      <div class="card card-body">
        <pre>{{res}}</pre>
      </div>
    </div>
    <div v-if="cplex" class="collapse" id="collCplex">
      <div class="card card-body">
        <pre>{{cplex}}</pre>
      </div>
    </div>
    </main>

    
    <script type="module">
        import { createApp } from 'vue';
        import GLPK from 'glpk';

        // vue app
        const app = createApp({
            created() {
                this.load();
            },
            data() {
              return {
                jsonl: [],
                uels: [],
                res: null,
                cplex: null,
                error: null
              }
            },
            methods: {
                load() {
                    // retrieve current ligands database
                    fetch('./data/uel-data.jsonl')
                        .then(resp => resp.text())
                        .then(text => {
                            this.jsonl = text.split(/\n/)
                                                .map(JSON.parse)
                                                .filter(o => o.hasOwnProperty('lig'))
                                                .map(o => {
                                                    // make sure all have a ignore property
                                                    o.ignore = (o.hasOwnProperty('ignore') && o.ignore)
                                                        ? o.ignore = true
                                                        : o.ignore = false;
                                                    return o;
                                                });
                        })
                        .catch(err => console.log(err));

                },
                clear() {
                    this.uels = [];    // computed UEL values
                    this.res = null;   // solver result
                    this.cplex = null; // optimization problem (cplex format)
                    this.error = null;
                },
                solve() {
                    // reset variables and status
                    this.clear();

                    // only use active constraints
                    var uels = this.jsonl.filter(o => o.ignore == false);

                    // single measurement: 
                    // {"lig": "<name>", "eqn": {"<comp>": 1, "<comp>": 3, "uel": -3.05}}
                    // multiple measurements:
                    // {"lig": "...", "eqn": {..., "uel": [-2.52, -2.41]}}

                    // build alias table for constraints (ligands) and variables (components)
                    const c2i = new Map();
                    const i2c = new Map();
                    const v2i = new Map();
                    const i2v = new Map();

                    // set error variable as first/0
                    v2i.set('err', 0);
                    i2v.set(0, 'err');

                    var cc = 1;
                    var vc = 1;
                    for (const uel of uels) {
                        if (c2i.has(uel.lig))
                            console.warn(`Duplicated constraint/ligand ${uel.lig}`);

                        // add constraint (ligand)
                        c2i.set(uel.lig, cc);
                        i2c.set(cc, uel.lig);
                        cc = cc + 1;

                        // add variables (components), if not present
                        for (const k of Object.keys(uel.eqn)) {
                            if (v2i.has(k)) continue;
                            v2i.set(k, vc);
                            i2v.set(vc, k);
                            vc = vc + 1;
                        }
                    }


                    GLPK().then(glpk => {
                        // build the constraints
                        const subjectTo = uels.flatMap((o, i) => {
                            let constr = Object.entries(o.eqn)
                                                  .map(([k, v]) => { return {name: `var_${v2i.get(k)}`, coef: v}; });
                            let uel = o.uel;

                            return [{
                                name: `constr_${i}_${c2i.get(o.lig)}_lo`,
                                vars: [constr, {name: 'err', coef: 1.0}].flat(),
                                bnds: {type: glpk.GLP_LO, ub: 0.0, lb: Array.isArray(uel) ? Math.min(...uel) : uel}
                            }, {
                                name: `constr_${i}_${c2i.get(o.lig)}_up`,
                                vars: [constr, {name: 'err', coef: -1.0}].flat(),
                                bnds: { type: glpk.GLP_UP, ub: Array.isArray(uel) ? Math.max(...uel) : uel, lb: 0.0}
                            }];
                        });

                        // define LP
                        const lp = {
                            name: 'LP',
                            objective: {
                                direction: glpk.GLP_MIN,
                                name: 'obj',
                                vars: [{name: 'err', coef: 1.0}]
                            },
                            subjectTo: subjectTo,
                            bounds: Array.from(i2v, ([k, v]) => { 
                                let a = (k == 0
                                    ? 'err'
                                    : `var_${k}`);
                                return {name: a, type: glpk.GLP_FR };
                            })
                        };

                        // configure solver
                        const opt = {
                            msglev: glpk.GLP_MSG_ALL,
                            presol: true,
                            /* no need for callbacks at this point...
                            cb: {
                                call: res => print(res),
                                each: 1
                            }
                            */
                        };

                        // run the optimization
                        glpk.solve(lp, opt)
                              .then(res => {
                                this.res = res;
                                this.uels = Array.from(i2v, ([k, v]) => {
                                  let a = (k == 0
                                    ? 'err'
                                    : `var_${k}`);
                                  return {var: a, name: v, i: k, val: res.result.vars[a]};
                                });

                                glpk.write(lp).then(res => {
                                  this.cplex = res;
                                });
                              })
                              .catch(err => {
                                this.error = err;
                                console.log(err);
                              });
                    });
                }
            }
        });
        
        app.mount('#app');
        </script>
</body>

</html>